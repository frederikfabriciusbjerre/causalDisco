#' @title causalDiscoSearch -- an R6 class frontend for **causalDisco**
#'
#' @description This class implements the search algorithms from the causalDisco
#' package, which wraps and adds temporal order to pcalg algorithms.
#' It allows to set the data, sufficient statistics, test, score, and algorithm.
#'
#' @importFrom R6 R6Class
#'
#' @R6example inst/roxygen-examples/causalDisco_search_example.R
#'
#' @export causalDiscoSearch
causalDiscoSearch <- R6::R6Class(
  "causalDiscoSearch",
  public = list(
    #' @field data A `data.frame` holding the data set currently attached to the
    #' search object. Can be set with `set_data()`.
    data = NULL,

    #' @field score A function that will be used to build the score,
    #'  when data is set. Can be set with \code{$set_score()}. Recognized values
    #'  are:
    #'  \itemize{
    #'     \item \code{tbic} - Temporal BIC score for Gaussian data.
    #'     See \code{\link[causalDisco:TemporalBIC-class]{TemporalBIC}}
    #'     \item \code{tbdeu} - Temporal BDeu score for discrete data.
    #'     See \code{\link[causalDisco:TemporalBDeu-class]{TemporalBDeu}}.
    #'     }
    score = NULL,

    #' @field test A function that will be used to test independence.
    #'  Can be set with \code{$set_test()}. Recognized values are:
    #'  \itemize{
    #'    \item \code{fisher_z} - Fisher Z test for Gaussian data.
    #'    See \code{\link[causalDisco:corTest]{corTest}}.
    #'    \item \code{reg} - Regression test for discrete or binary data.
    #'    See \code{\link[causalDisco:regTest]{regTest}}.
    #'    }
    test = NULL,

    #' @field alg A function that will be used to run the search algorithm.
    #' Can be set with \code{$set_alg()}. Recognized values are:
    #' \itemize{
    #'   \item \code{tpc}  - TPC algorithm.
    #'   See \code{\link[causalDisco:tpc]{tpc}}.
    #'   \item \code{tfci} - TFCI algorithm.
    #'   See \code{\link[causalDisco:tfci]{tfci}}.
    #'   \item \code{tges} - TGES algorithm.
    #'   See \code{\link[causalDisco:tges]{tges}}.
    #'   }
    alg = NULL,

    #' @field params A list of parameters for the test and algorithm.
    #' Can be set with \code{$set_params()}.
    #' TODO: not secure yet in terms of distributing arguments.
    #' Use with caution.
    params = NULL,

    #' @field suff_stat Sufficient statistic. The format and contents of the
    #' sufficient statistic depends on which test is being used.
    suff_stat = NULL,

    #' @field knowledge A `knowledge` object holding background knowledge.
    knowledge = NULL,

    #' @description
    #' Constructor for the `causalDiscoSearch` class.
    initialize = function() {
      .check_if_pkgs_are_installed(
        pkgs = c(
          "pcalg", "purrr", "R6", "rlang", "stats", "utils"
        ),
        class_name = "causalDiscoSearch"
      )

      self$data <- NULL
      self$score <- NULL
      self$test <- NULL
      self$knowledge <- NULL
      self$params <- list(
        methodNA = "none"
      )
    },

    #' @description
    #' Sets the parameters for the test and algorithm.
    #'
    #' @param params A list of parameters to set.
    set_params = function(params) {
      if (is.null(params)) {
        return(invisible(self))
      }
      reserved <- c(
        "data", "suffStat", "knowledge", "score", "test", "labels"
      )
      bad <- intersect(names(params), reserved)
      if (length(bad)) {
        stop(
          "These parameters are reserved and cannot be set via set_params(): ",
          paste(bad, collapse = ", "),
          call. = FALSE
        )
      }
      # allow overriding default output/methodNA/verbose/etc.
      self$params <- utils::modifyList(self$params, params)
      invisible(self)
    },

    #' @description
    #' Sets the data for the search algorithm.
    #'
    #' @param data A `data.frame` or a `matrix` containing the data.
    #' @param set_suff_stat Logical; whether to set the sufficient statistic.
    set_data = function(data, set_suff_stat = TRUE) {
      self$data <- data
      if (set_suff_stat) {
        self$set_suff_stat()
      }

      invisible(self)
    },

    #' @description
    #' Sets the sufficient statistic for the data.
    set_suff_stat = function() {
      if (is.null(self$data)) {
        stop("Data must be set before sufficient statistic.", call. = FALSE)
      }
      if (is.null(self$test)) {
        stop("Test must be set before sufficient statistic.", call. = FALSE)
      }

      switch(private$test_kind,
        "fisher_z" = {
          if (!(is.matrix(self$data) || is.data.frame(self$data))) {
            stop("Data must be a matrix or data frame.", call. = FALSE)
          }
          self$suff_stat <- list(
            C = stats::cor(self$data, use = "pairwise.complete.obs"),
            n = nrow(self$data)
          )
        },
        "reg" = {
          self$suff_stat <- make_suff_stat(self$data, type = "regTest")
        },
        # extra precaution
        stop("Internal: unsupported test kind.", call. = FALSE) # nocov
      )
      invisible(self)
    },

    #' @description
    #' Sets the test for the search algorithm.
    #'
    #' @param method A string specifying the type of test to use.
    #' @param alpha Significance level for the test.
    set_test = function(method, alpha = NULL) {
      method <- tolower(method)
      if (!is.null(alpha)) {
        self$params$alpha <- alpha
      }
      switch(method,
        "fisher_z" = {
          self$test <- corTest
          private$test_kind <- "fisher_z"
        },
        "reg" = {
          self$test <- regTest
          private$test_kind <- "reg"
        },
        stop("Unknown test type using causalDisco engine: ", method,
          call. = FALSE
        )
      )
      invisible(self)
    },

    #' @description
    #' Sets the score for the search algorithm.
    #'
    #' @param method A string specifying the type of score to use.
    #' @param params A list of parameters to pass to the score function.
    set_score = function(method, params = list()) {
      method <- tolower(method)
      allowed <- c("tbic", "tbdeu")
      if (!(method %in% allowed)) {
        stop("Unknown score type using causalDisco engine: ", method, call. = FALSE)
      }

      private$score_method <- method
      private$score_params <- if (is.null(params)) list() else params

      private$score_function <- function() {
        if (is.null(self$data)) {
          stop("Data must be set before score.", call. = FALSE)
        }

        if (identical(private$score_method, "tbic")) {
          # Gaussian temporal score
          return(rlang::exec(
            "new",
            Class = "TemporalBIC",
            data = self$data,
            nodes = colnames(self$data),
            knowledge = self$knowledge,
            !!!private$score_params
          ))
        }

        if (identical(private$score_method, "tbdeu")) {
          # Categorical temporal score
          return(rlang::exec(
            "new",
            Class = "TemporalBDeu",
            data = self$data,
            nodes = colnames(self$data),
            knowledge = self$knowledge,
            !!!private$score_params
          ))
        }

        stop("Internal: unsupported score method.", call. = FALSE)
      }

      invisible(self)
    },

    #' @description
    #' Sets the algorithm for the search.
    #'
    #' @param method A string specifying the type of algorithm to use.
    set_alg = function(method) {
      method <- tolower(method)
      private$alg_method <- method

      switch(method,
        "tpc" = {
          if (is.null(self$test)) {
            stop("No test is set. Use set_test() first.", call. = FALSE)
          }
          self$alg <- purrr::partial(
            tpc_run,
            test = self$test,
            !!!self$params
          )
        },
        "tfci" = {
          if (is.null(self$test)) {
            stop("No test is set. Use set_test() first.", call. = FALSE)
          }
          self$alg <- purrr::partial(
            tfci_run,
            test = self$test,
            !!!self$params
          )
        },
        "tges" = {
          self$alg <- purrr::partial(
            tges_run,
            verbose = isTRUE(self$params$verbose)
          )
        },
        stop("Unknown method type using causalDisco engine: ", method,
          call. = FALSE
        )
      )

      invisible(self)
    },

    #' @description
    #'
    #' Sets the background knowledge for the search with a `knowledge` object.
    #'
    #' @param kn A `knowledge` object.
    #' @param directed_as_undirected Logical; whether to treat directed edges in
    #' the knowledge as undirected. Default is `FALSE`. This is due to the
    #' nature of how `pcalg` handles background knowledge when using
    #' \code{\link[pcalg:skeleton]{skeleton}} under the hood in
    #' \code{\link[causalDisco:tpc]{tpc}} and
    #' \code{\link[causalDisco:tfci]{tfci}}.
    #' @seealso \code{\link[causalDisco:knowledge]{knowledge}}.
    set_knowledge = function(kn, directed_as_undirected = FALSE) {
      is_knowledge(kn)
      self$knowledge <- kn
      private$directed_as_undirected <- directed_as_undirected
      invisible(self)
    },

    #' @description
    #' Runs the search algorithm on the data.
    #'
    #' @param data A `data.frame` or a `matrix` containing the data.
    #' @param set_suff_stat Logical; whether to set the sufficient statistic
    run_search = function(data = NULL, set_suff_stat = TRUE) {
      if (!is.null(data)) {
        if (is.null(private$score_function)) {
          self$set_data(data, set_suff_stat = set_suff_stat)
        } else {
          self$set_data(data, set_suff_stat = FALSE)
        }
      }
      if (is.null(self$data)) {
        stop("No data is set. Use set_data() first or pass data to ",
          "run_search().",
          call. = FALSE
        )
      }
      if (is.null(self$alg)) {
        stop("No algorithm is set. Use set_alg() first.", call. = FALSE)
      }

      # constraint-based path
      if (!identical(private$alg_method, "tges")) {
        if (is.null(self$suff_stat) && set_suff_stat) {
          stop("No sufficient statistic is set. Use set_data() first.",
            call. = FALSE
          )
        }
        res <- self$alg(
          data = self$data,
          knowledge = self$knowledge,
          suffStat = self$suff_stat
        )
        return(res)
      } else {
        # score-based path (tges)
        if (is.null(private$score_function)) {
          stop("No score is set. Use set_score() first.", call. = FALSE)
        }
        self$score <- private$score_function()

        if (!is.null(self$knowledge)) {
          res <- self$alg(
            score = self$score
          )
        } else {
          res <- self$alg(
            score = self$score
          )
        }
        return(res)
      }
    }
  ),
  private = list(
    alg_method = NULL, # "tpc", "tfci", or "tges"
    test_kind = NULL, # "fisher_z" or "reg"
    directed_as_undirected = FALSE,
    score_method = NULL,
    score_params = NULL,
    score_function = NULL
  )
)
