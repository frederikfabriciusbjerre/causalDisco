% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/knowledge.R
\name{as_pcalg_constraints}
\alias{as_pcalg_constraints}
\title{Convert background knowledge to pcalg constraint matrices}
\usage{
as_pcalg_constraints(
  .kn,
  labels = .kn$vars$var,
  directed_as_undirected = FALSE
)
}
\arguments{
\item{.kn}{A \code{knowledge} object.  Must have no tier information.}

\item{labels}{Character vector of all variable names, in the exact order
of your data columns.  Every variable referenced by an edge in \code{.kn}
must appear here.}

\item{directed_as_undirected}{Logical (default \code{FALSE}).  If
\code{FALSE}, we require that every edge in \code{.kn} has its
mirror-image present as well, and will error if any are missing.  If
\code{TRUE}, we automatically mirror every directed edge into
an undirected constraint.}
}
\value{
A list with two elements, each an \code{n × n} logical matrix
corresponding to \code{pcalg}'s \code{fixedGaps} and \code{fixedEdges} arguments.
}
\description{
pcalg only supports \emph{undirected} (symmetric) background constraints:
\itemize{
\item \strong{fixedGaps}  — forbidding edges (zeros enforced)
\item \strong{fixedEdges} — requiring edges (ones enforced)
}
}
\details{
This function takes a \code{knowledge} object (with only forbidden/required
edges, no tiers) and returns the two logical matrices in the exact
variable order you supply.
}
\section{Errors}{

\itemize{
\item If the knowledge object contains tiered knowledge.
\item If \code{directed_as_undirected = FALSE} and any edge lacks its
symmetrical counterpart. This can only hold for forbidden edges.
}
}

\examples{
### as_pcalg_constraints() example ###

# pcalg supports undirected constraints; build a tierless knowledge and convert
data(tpcExample)

kn <- knowledge(
  tpcExample,
  forbidden(child_x1 ~ youth_x3),
  forbidden(youth_x3 ~ child_x1)
)

pc_constraints <- as_pcalg_constraints(kn, directed_as_undirected = FALSE)
print(pc_constraints)

# error paths
# using tiers
kn <- knowledge(
  tpcExample,
  tier(
    child ~ starts_with("child"),
    youth ~ starts_with("youth"),
    oldage ~ starts_with("old")
  ),
  required(child_x1 ~ youth_x3)
)

try(as_pcalg_constraints(kn), silent = TRUE) # fails due to tiers

# using directed knowledge
kn <- knowledge(
  tpcExample,
  forbidden(child_x1 ~ youth_x3)
)

try(as_pcalg_constraints(kn), silent = TRUE) # fails due to directed knowledge
}
